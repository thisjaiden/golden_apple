use serde::Deserialize;
use serde_json::{Value, Map};

const AUTOGENERATED: &str = 
"/*
 * THIS FILE IS AUTOGENERATED BY golden_apple::build.rs
 * MODIFICATIONS WILL BE OVERWRITTEN
 */
";

fn main() -> Result<(), serde_json::Error> {
    let registries_bytes = include_bytes!("mojang/registries.json");
    let blockstates_bytes = include_bytes!("mojang/blocks.json");
    let registries: Registries = serde_json::from_slice(registries_bytes)?;
    generate_enum(
        registries.mob_effect.entries.as_object().unwrap(),
        "potion_effects.rs",
        "PotionEffect",
        "/// Represents any effect that can be given, via potions or otherwise"
    );
    generate_enum(
        registries.block.entries.as_object().unwrap(),
        "blocks.rs",
        "Block",
        "/// This represents the block's ID, **NOT** the blockstate ID!"
    );
    generate_enum(
        registries.enchantment.entries.as_object().unwrap(),
        "enchantments.rs",
        "Enchantment",
        "/// All enchantments and curses"
    );
    generate_enum(
        registries.entity_type.entries.as_object().unwrap(),
        "entity_types.rs",
        "EntityType",
        ""
    );
    generate_enum(
        registries.item.entries.as_object().unwrap(),
        "items.rs",
        "Item",
        ""
    );
    generate_enum(
        registries.particle_type.entries.as_object().unwrap(),
        "particles.rs",
        "Particle",
        ""
    );
    generate_enum(
        registries.profession.entries.as_object().unwrap(),
        "professions.rs",
        "VillagerProfession",
        ""
    );
    generate_enum(
        registries.painting.entries.as_object().unwrap(),
        "paintings.rs",
        "Painting",
        ""
    );
    generate_enum(
        registries.custom_stat.entries.as_object().unwrap(),
        "custom_stats.rs",
        "CustomStatistic",
        "/// Represents a statistic that doesn't fall under the main categories"
    );
    Ok(())
}

#[derive(Deserialize)]
struct Registries {
    #[serde(rename(deserialize = "minecraft:sound_event"))]
    sound_event: Registry,
    #[serde(rename(deserialize = "minecraft:fluid"))]
    fluid: Registry,
    #[serde(rename(deserialize = "minecraft:mob_effect"))]
    mob_effect: Registry,
    #[serde(rename(deserialize = "minecraft:block"))]
    block: Registry,
    #[serde(rename(deserialize = "minecraft:enchantment"))]
    enchantment: Registry,
    #[serde(rename(deserialize = "minecraft:entity_type"))]
    entity_type: Registry,
    #[serde(rename(deserialize = "minecraft:item"))]
    item: Registry,
    #[serde(rename(deserialize = "minecraft:particle_type"))]
    particle_type: Registry,
    #[serde(rename(deserialize = "minecraft:potion"))]
    potion: Registry,
    #[serde(rename(deserialize = "minecraft:villager_profession"))]
    profession: Registry,
    #[serde(rename(deserialize = "minecraft:painting_variant"))]
    painting: Registry,
    #[serde(rename(deserialize = "minecraft:custom_stat"))]
    custom_stat: Registry,
}

#[derive(Deserialize)]
struct Registry {
    protocol_id: u8,
    default: Option<String>,
    entries: Value
}

/// An entry in a registry is made up of the namespaced entry name and its protocol ID.
type Entries = Vec<(String, u32)>;

fn convert_to_camel_case(snake_case: &str) -> String {
    let mut last_char = None;
    let mut final_out = String::new();
    for char in snake_case.chars() {
        if char == '_' {
            // don't write _ to end name
        }
        else if last_char == Some('_') {
            final_out += &char.to_ascii_uppercase().to_string();
        }
        else {
            final_out += &char.to_string();
        }
        last_char = Some(char);
    }
    let mut tmp_iter = final_out.chars();
    tmp_iter.next().unwrap();
    let final_final_out = format!("{}{}", final_out.chars().take(1).next().unwrap().to_ascii_uppercase(), tmp_iter.as_str());
    return final_final_out;
}

fn generate_enum(data_bloq: &Map<String, Value>, save_loc: &str, enum_name: &str, doc_comment: &str) {
    let mut constructed_blocks = String::from(AUTOGENERATED);
    constructed_blocks += doc_comment;
    constructed_blocks += "\n";
    constructed_blocks += "#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n";
    constructed_blocks += "pub enum ";
    constructed_blocks += enum_name;
    constructed_blocks += " {\n";
    let mut all_blocks: Entries = vec![];
    for (name, value) in data_bloq.iter() {
        all_blocks.push((name.clone(), value["protocol_id"].as_i64().unwrap() as u32));
    }
    all_blocks.sort_by(|a, b| { a.1.cmp(&b.1) });
    let mut cleaned_names = vec![];
    for (name, id) in all_blocks {
        let cleaned_name = convert_to_camel_case(name.strip_prefix("minecraft:").unwrap());
        constructed_blocks += &format!("    {}", cleaned_name);
        constructed_blocks += &format!(" = {},\n", id);
        cleaned_names.push(cleaned_name);
    }
    constructed_blocks += "}\n\n";
    constructed_blocks += "impl TryFrom<u32> for ";
    constructed_blocks += enum_name;
    constructed_blocks += " {\n";
    constructed_blocks += "    type Error = Error;\n";
    constructed_blocks += "    fn try_from(value: u32) -> Result<Self, Self::Error> {\n";
    constructed_blocks += "        match value {\n";
    for name in cleaned_names {
        constructed_blocks += "            x if x == Self::";
        constructed_blocks += &name;
        constructed_blocks += " as u32 => Ok(Self::";
        constructed_blocks += &name;
        constructed_blocks += "),\n";
    }
    constructed_blocks += "            _ => Err(Error::EnumOutOfBound)\n";
    constructed_blocks += "        }\n    }\n}\n";
    let valid_out = std::env::var_os("OUT_DIR").unwrap();
    let destination = std::path::Path::new(&valid_out).join(save_loc);
    std::fs::write(destination, constructed_blocks).unwrap();
}
