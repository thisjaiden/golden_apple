use serde::Deserialize;
use serde_json::{Value, Map};

fn main() -> Result<(), serde_json::Error> {
    let registries_bytes = include_bytes!("mojang/registries.json");
    let blockstates_bytes = include_bytes!("mojang/blocks.json");
    let registries: Registries = serde_json::from_slice(registries_bytes)?;
    generate_enum(
        registries.mob_effect.entries.as_object().unwrap(),
        "src/enums/potion_effects.rs",
        "PotionEffect",
        ""
    );
    generate_enum(
        registries.block.entries.as_object().unwrap(),
        "src/enums/blocks.rs",
        "Block",
        "/// This represents the block's ID, **NOT** the blockstate ID!"
    );
    generate_enum(
        registries.enchantment.entries.as_object().unwrap(),
        "src/enums/enchantments.rs",
        "Enchantment",
        ""
    );
    generate_enum(
        registries.entity_type.entries.as_object().unwrap(),
        "src/enums/entity_type.rs",
        "EntityType",
        ""
    );
    generate_enum(
        registries.item.entries.as_object().unwrap(),
        "src/enums/items.rs",
        "Item",
        ""
    );
    generate_enum(
        registries.particle_type.entries.as_object().unwrap(),
        "src/enums/particles.rs",
        "Particle",
        ""
    );
    generate_enum(
        registries.profession.entries.as_object().unwrap(),
        "src/enums/professions.rs",
        "VillagerProfession",
        ""
    );
    generate_enum(
        registries.painting.entries.as_object().unwrap(),
        "src/enums/paintings.rs",
        "Painting",
        ""
    );
    generate_enum(
        registries.custom_stat.entries.as_object().unwrap(),
        "src/enums/custom_stats.rs",
        "CustomStatistic",
        "/// Represents a statistic that doesn't fall under the main categories"
    );
    Ok(())
}

#[derive(Deserialize)]
struct Registries {
    #[serde(rename(deserialize = "minecraft:sound_event"))]
    sound_event: Registry,
    #[serde(rename(deserialize = "minecraft:fluid"))]
    fluid: Registry,
    #[serde(rename(deserialize = "minecraft:mob_effect"))]
    mob_effect: Registry,
    #[serde(rename(deserialize = "minecraft:block"))]
    block: Registry,
    #[serde(rename(deserialize = "minecraft:enchantment"))]
    enchantment: Registry,
    #[serde(rename(deserialize = "minecraft:entity_type"))]
    entity_type: Registry,
    #[serde(rename(deserialize = "minecraft:item"))]
    item: Registry,
    #[serde(rename(deserialize = "minecraft:particle_type"))]
    particle_type: Registry,
    #[serde(rename(deserialize = "minecraft:potion"))]
    potion: Registry,
    #[serde(rename(deserialize = "minecraft:villager_profession"))]
    profession: Registry,
    #[serde(rename(deserialize = "minecraft:painting_variant"))]
    painting: Registry,
    #[serde(rename(deserialize = "minecraft:custom_stat"))]
    custom_stat: Registry,
}

#[derive(Deserialize)]
struct Registry {
    protocol_id: u8,
    default: Option<String>,
    entries: Value
}

/// An entry in a registry is made up of the namespaced entry name and its protocol ID.
type Entries = Vec<(String, u32)>;

fn convert_to_camel_case(snake_case: &str) -> String {
    let mut last_char = 'E';
    let mut final_out = String::new();
    for char in snake_case.chars() {
        if char == '_' {
            // don't write _ to end name
        }
        else if last_char == '_' {
            final_out += &char.to_ascii_uppercase().to_string();
        }
        else {
            final_out += &char.to_string();
        }
        last_char = char;
    }
    return final_out;
}

fn generate_enum(data_bloq: &Map<String, Value>, save_loc: &str, enum_name: &str, doc_comment: &str) {
    let mut constructed_blocks = String::from(AUTOGENERATED);
    constructed_blocks += doc_comment;
    constructed_blocks += "\n";
    constructed_blocks += "#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n";
    constructed_blocks += "pub enum ";
    constructed_blocks += enum_name;
    constructed_blocks += " {\n";
    let mut all_blocks: Entries = vec![];
    for (name, value) in data_bloq.iter() {
        all_blocks.push((name.clone(), value["protocol_id"].as_i64().unwrap() as u32));
    }
    all_blocks.sort_by(|a, b| { a.1.cmp(&b.1) });
    let mut cleaned_names = vec![];
    for (name, id) in all_blocks {
        let cleaned_name = convert_to_camel_case(name.strip_prefix("minecraft:").unwrap());
        let mut tmp_iter = cleaned_name.chars();
        tmp_iter.next().unwrap();
        constructed_blocks += &format!("    {}{}", cleaned_name.chars().take(1).next().unwrap().to_ascii_uppercase(), tmp_iter.as_str());
        constructed_blocks += &format!(" = {},\n", id);
        cleaned_names.push(format!("{}{}", cleaned_name.chars().take(1).next().unwrap().to_ascii_uppercase(), tmp_iter.as_str()));
    }
    constructed_blocks += "}\n\n";
    constructed_blocks += "use std::convert::TryFrom;\n";
    constructed_blocks += "impl TryFrom<u32> for ";
    constructed_blocks += enum_name;
    constructed_blocks += " {\n";
    constructed_blocks += "    type Error = crate::Error;\n";
    constructed_blocks += "    fn try_from(value: u32) -> Result<Self, Self::Error> {\n";
    constructed_blocks += "        match value {\n";
    for name in cleaned_names {
        constructed_blocks += "            x if x == Self::";
        constructed_blocks += &name;
        constructed_blocks += " as u32 => Ok(Self::";
        constructed_blocks += &name;
        constructed_blocks += "),\n";
    }
    constructed_blocks += "            _ => Err(Self::Error::EnumOutOfBound)\n";
    constructed_blocks += "        }\n    }\n}\n";
    std::fs::write(save_loc, constructed_blocks).unwrap();
}

const AUTOGENERATED: &str = 
"/*
 * THIS FILE IS AUTOGENERATED BY build.rs
 * MODIFICATIONS WILL BE OVERWRITTEN
 */
";
